# Allspark2-Orin NX平台Reachy Mini机器人详细技术实现方案

## 项目结构设计

```
reachy-mini-project/
├── backend/                    # 后端服务
│   ├── python/                # Python服务模块
│   │   ├── api/              # FastAPI接口
│   │   ├── core/             # 核心业务逻辑
│   │   ├── models/           # 数据模型
│   │   ├── services/         # 业务服务
│   │   └── utils/            # 工具函数
│   ├── rust/                 # Rust高性能模块
│   │   ├── src/              # Rust源码
│   │   ├── Cargo.toml        # Rust依赖配置
│   │   └── build.rs          # 构建脚本
│   └── ros2/                 # ROS2节点
│       ├── launch/           # 启动文件
│       ├── src/              # ROS2节点源码
│       └── package.xml       # ROS2包配置
├── frontend/                  # 前端应用
│   ├── src/                  # React源码
│   │   ├── components/       # React组件
│   │   ├── hooks/            # 自定义Hooks
│   │   ├── services/         # API服务
│   │   ├── types/            # TypeScript类型
│   │   └── utils/            # 工具函数
│   ├── public/               # 静态资源
│   └── package.json          # 前端依赖
├── models/                   # AI模型文件
│   ├── vision/               # 视觉模型
│   ├── audio/                # 音频模型
│   └── nlp/                  # 自然语言处理模型
├── config/                   # 配置文件
│   ├── docker/               # Docker配置
│   ├── nginx/                # Nginx配置
│   └── env/                  # 环境配置
├── scripts/                  # 部署脚本
├── docs/                     # 文档
└── tests/                    # 测试文件
```

## 后端详细实现

### 1. Python FastAPI服务实现

#### 主应用入口 (backend/python/main.py)
```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
import asyncio
import logging
from contextlib import asynccontextmanager

from api.routes import robot, stream, ai
from core.robot_controller import ReachyController
from core.websocket_manager import WebSocketManager
from services.ai_service import AIService

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 全局服务实例
robot_controller = None
websocket_manager = None
ai_service = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    global robot_controller, websocket_manager, ai_service
    
    # 启动时初始化服务
    logger.info("初始化服务...")
    robot_controller = ReachyController()
    websocket_manager = WebSocketManager()
    ai_service = AIService()
    
    await robot_controller.initialize()
    await ai_service.load_models()
    
    logger.info("服务初始化完成")
    yield
    
    # 关闭时清理资源
    logger.info("清理资源...")
    await robot_controller.cleanup()
    await ai_service.cleanup()
    logger.info("资源清理完成")

# 创建FastAPI应用
app = FastAPI(
    title="Reachy Mini Control API",
    description="Allspark2-Orin NX平台Reachy Mini机器人控制API",
    version="1.0.0",
    lifespan=lifespan
)

# 配置CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # 生产环境应限制具体域名
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 静态文件服务
app.mount("/static", StaticFiles(directory="static"), name="static")

# 注册路由
app.include_router(robot.router, prefix="/api/robot", tags=["robot"])
app.include_router(stream.router, prefix="/api/stream", tags=["stream"])
app.include_router(ai.router, prefix="/api/ai", tags=["ai"])

@app.websocket("/ws/control")
async def websocket_control_endpoint(websocket: WebSocket):
    """机器人控制WebSocket接口"""
    await websocket_manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_json()
            await websocket_manager.handle_message(websocket, data)
    except WebSocketDisconnect:
        websocket_manager.disconnect(websocket)

@app.websocket("/ws/stream")
async def websocket_stream_endpoint(websocket: WebSocket):
    """视频流WebSocket接口"""
    await websocket.accept()
    try:
        # 启动视频流传输
        await robot_controller.start_video_stream(websocket)
    except WebSocketDisconnect:
        logger.info("视频流客户端断开连接")

@app.get("/")
async def root():
    return {"message": "Reachy Mini Control API is running"}

@app.get("/health")
async def health_check():
    """健康检查接口"""
    return {
        "status": "healthy",
        "robot_connected": robot_controller.is_connected() if robot_controller else False,
        "ai_models_loaded": ai_service.models_loaded() if ai_service else False
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
```

#### 机器人控制器 (backend/python/core/robot_controller.py)
```python
import asyncio
import cv2
import numpy as np
from typing import Optional, Dict, Any
import logging
from reachy_sdk import ReachySDK
from reachy_sdk.trajectory import goto

logger = logging.getLogger(__name__)

class ReachyController:
    """Reachy机器人控制器"""
    
    def __init__(self, host: str = "localhost", port: int = 50055):
        self.host = host
        self.port = port
        self.reachy: Optional[ReachySDK] = None
        self.is_streaming = False
        self.current_position = {
            "head": {"pitch": 0, "yaw": 0, "roll": 0},
            "body": {"rotation": 0}
        }
        
    async def initialize(self):
        """初始化机器人连接"""
        try:
            self.reachy = ReachySDK(host=self.host, port=self.port)
            logger.info(f"成功连接到Reachy机器人: {self.host}:{self.port}")
            
            # 初始化机器人状态
            await self._initialize_robot_state()
            
        except Exception as e:
            logger.error(f"连接Reachy机器人失败: {e}")
            raise
    
    async def _initialize_robot_state(self):
        """初始化机器人状态"""
        if not self.reachy:
            return
            
        # 设置初始姿态
        self.reachy.head.compliant = False
        
        # 回到初始位置
        initial_position = {
            self.reachy.head.neck_pitch: 0,
            self.reachy.head.neck_yaw: 0,
            self.reachy.head.neck_roll: 0,
        }
        
        goto(initial_position, duration=2.0)
        await asyncio.sleep(2.0)
        
        logger.info("机器人初始化完成")
    
    async def move_head(self, pitch: float, yaw: float, roll: float, duration: float = 1.0):
        """控制头部运动"""
        if not self.reachy:
            raise RuntimeError("机器人未连接")
        
        try:
            # 限制角度范围
            pitch = np.clip(pitch, -30, 30)
            yaw = np.clip(yaw, -90, 90)
            roll = np.clip(roll, -30, 30)
            
            target_position = {
                self.reachy.head.neck_pitch: np.deg2rad(pitch),
                self.reachy.head.neck_yaw: np.deg2rad(yaw),
                self.reachy.head.neck_roll: np.deg2rad(roll),
            }
            
            goto(target_position, duration=duration)
            
            # 更新当前位置
            self.current_position["head"] = {
                "pitch": pitch,
                "yaw": yaw,
                "roll": roll
            }
            
            logger.info(f"头部移动到: pitch={pitch}, yaw={yaw}, roll={roll}")
            
        except Exception as e:
            logger.error(f"头部运动控制失败: {e}")
            raise
    
    async def rotate_body(self, angle: float, duration: float = 2.0):
        """控制身体旋转"""
        if not self.reachy:
            raise RuntimeError("机器人未连接")
        
        try:
            # 限制旋转角度
            angle = angle % 360
            if angle > 180:
                angle -= 360
            
            # 这里需要根据实际硬件接口实现身体旋转
            # 假设通过某个电机控制
            logger.info(f"身体旋转到: {angle}度")
            
            self.current_position["body"]["rotation"] = angle
            
        except Exception as e:
            logger.error(f"身体旋转控制失败: {e}")
            raise
    
    async def get_camera_frame(self) -> Optional[np.ndarray]:
        """获取摄像头帧"""
        if not self.reachy:
            return None
        
        try:
            # 获取摄像头图像
            frame = self.reachy.cameras.left.last_frame
            if frame is not None:
                return cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            return None
            
        except Exception as e:
            logger.error(f"获取摄像头帧失败: {e}")
            return None
    
    async def start_video_stream(self, websocket):
        """启动视频流传输"""
        self.is_streaming = True
        logger.info("开始视频流传输")
        
        try:
            while self.is_streaming:
                frame = await self.get_camera_frame()
                if frame is not None:
                    # 压缩图像
                    _, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 80])
                    frame_data = buffer.tobytes()
                    
                    # 发送到WebSocket
                    await websocket.send_bytes(frame_data)
                
                await asyncio.sleep(1/30)  # 30 FPS
                
        except Exception as e:
            logger.error(f"视频流传输错误: {e}")
        finally:
            self.is_streaming = False
            logger.info("视频流传输结束")
    
    def stop_video_stream(self):
        """停止视频流传输"""
        self.is_streaming = False
    
    def get_status(self) -> Dict[str, Any]:
        """获取机器人状态"""
        if not self.reachy:
            return {"connected": False}
        
        return {
            "connected": True,
            "position": self.current_position,
            "streaming": self.is_streaming,
            "temperature": self._get_temperature(),
            "battery": self._get_battery_level()
        }
    
    def _get_temperature(self) -> float:
        """获取温度信息"""
        # 实际实现中应该从硬件获取
        return 35.5
    
    def _get_battery_level(self) -> int:
        """获取电池电量"""
        # 实际实现中应该从硬件获取
        return 85
    
    def is_connected(self) -> bool:
        """检查连接状态"""
        return self.reachy is not None
    
    async def cleanup(self):
        """清理资源"""
        if self.reachy:
            self.stop_video_stream()
            self.reachy.head.compliant = True
            logger.info("机器人控制器清理完成")
```

#### WebSocket管理器 (backend/python/core/websocket_manager.py)
```python
import json
import asyncio
from typing import List, Dict, Any
from fastapi import WebSocket
import logging

logger = logging.getLogger(__name__)

class WebSocketManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.robot_controller = None
    
    def set_robot_controller(self, controller):
        """设置机器人控制器引用"""
        self.robot_controller = controller
    
    async def connect(self, websocket: WebSocket):
        """接受WebSocket连接"""
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(f"WebSocket客户端连接: {len(self.active_connections)}个活跃连接")
    
    def disconnect(self, websocket: WebSocket):
        """断开WebSocket连接"""
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
        logger.info(f"WebSocket客户端断开: {len(self.active_connections)}个活跃连接")
    
    async def send_personal_message(self, message: str, websocket: WebSocket):
        """发送个人消息"""
        await websocket.send_text(message)
    
    async def broadcast(self, message: str):
        """广播消息给所有连接"""
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except Exception as e:
                logger.error(f"广播消息失败: {e}")
                self.disconnect(connection)
    
    async def handle_message(self, websocket: WebSocket, data: Dict[str, Any]):
        """处理WebSocket消息"""
        try:
            message_type = data.get("type")
            payload = data.get("payload", {})
            
            if message_type == "move_head":
                await self._handle_move_head(websocket, payload)
            elif message_type == "rotate_body":
                await self._handle_rotate_body(websocket, payload)
            elif message_type == "get_status":
                await self._handle_get_status(websocket)
            elif message_type == "start_stream":
                await self._handle_start_stream(websocket)
            elif message_type == "stop_stream":
                await self._handle_stop_stream(websocket)
            else:
                await self.send_personal_message(
                    json.dumps({"error": f"未知消息类型: {message_type}"}),
                    websocket
                )
                
        except Exception as e:
            logger.error(f"处理WebSocket消息失败: {e}")
            await self.send_personal_message(
                json.dumps({"error": str(e)}),
                websocket
            )
    
    async def _handle_move_head(self, websocket: WebSocket, payload: Dict[str, Any]):
        """处理头部运动命令"""
        if not self.robot_controller:
            await self.send_personal_message(
                json.dumps({"error": "机器人控制器未初始化"}),
                websocket
            )
            return
        
        pitch = payload.get("pitch", 0)
        yaw = payload.get("yaw", 0)
        roll = payload.get("roll", 0)
        duration = payload.get("duration", 1.0)
        
        try:
            await self.robot_controller.move_head(pitch, yaw, roll, duration)
            await self.send_personal_message(
                json.dumps({
                    "type": "move_head_response",
                    "success": True,
                    "position": {"pitch": pitch, "yaw": yaw, "roll": roll}
                }),
                websocket
            )
        except Exception as e:
            await self.send_personal_message(
                json.dumps({
                    "type": "move_head_response",
                    "success": False,
                    "error": str(e)
                }),
                websocket
            )
    
    async def _handle_rotate_body(self, websocket: WebSocket, payload: Dict[str, Any]):
        """处理身体旋转命令"""
        if not self.robot_controller:
            await self.send_personal_message(
                json.dumps({"error": "机器人控制器未初始化"}),
                websocket
            )
            return
        
        angle = payload.get("angle", 0)
        duration = payload.get("duration", 2.0)
        
        try:
            await self.robot_controller.rotate_body(angle, duration)
            await self.send_personal_message(
                json.dumps({
                    "type": "rotate_body_response",
                    "success": True,
                    "angle": angle
                }),
                websocket
            )
        except Exception as e:
            await self.send_personal_message(
                json.dumps({
                    "type": "rotate_body_response",
                    "success": False,
                    "error": str(e)
                }),
                websocket
            )
    
    async def _handle_get_status(self, websocket: WebSocket):
        """处理状态查询"""
        if not self.robot_controller:
            await self.send_personal_message(
                json.dumps({"error": "机器人控制器未初始化"}),
                websocket
            )
            return
        
        status = self.robot_controller.get_status()
        await self.send_personal_message(
            json.dumps({
                "type": "status_response",
                "status": status
            }),
            websocket
        )
    
    async def _handle_start_stream(self, websocket: WebSocket):
        """处理开始视频流命令"""
        if not self.robot_controller:
            await self.send_personal_message(
                json.dumps({"error": "机器人控制器未初始化"}),
                websocket
            )
            return
        
        # 在新的任务中启动视频流
        asyncio.create_task(self.robot_controller.start_video_stream(websocket))
        
        await self.send_personal_message(
            json.dumps({
                "type": "start_stream_response",
                "success": True
            }),
            websocket
        )
    
    async def _handle_stop_stream(self, websocket: WebSocket):
        """处理停止视频流命令"""
        if not self.robot_controller:
            await self.send_personal_message(
                json.dumps({"error": "机器人控制器未初始化"}),
                websocket
            )
            return
        
        self.robot_controller.stop_video_stream()
        
        await self.send_personal_message(
            json.dumps({
                "type": "stop_stream_response",
                "success": True
            }),
            websocket
        )
```

### 2. Rust高性能模块实现

#### Cargo.toml配置
```toml
[package]
name = "reachy-rust-core"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { version = "1.0", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tonic = "0.10"
prost = "0.12"
opencv = { version = "0.88", features = ["opencv-4"] }
image = "0.24"
byteorder = "1.4"
log = "0.4"
env_logger = "0.10"
pyo3 = { version = "0.20", features = ["extension-module"] }
numpy = "0.20"

[build-dependencies]
tonic-build = "0.10"

[lib]
name = "reachy_rust_core"
crate-type = ["cdylib"]
```

#### 视觉处理模块 (backend/rust/src/vision.rs)
```rust
use opencv::{
    core::{Mat, Point, Scalar, Size, Vector},
    imgproc::{self, INTER_LINEAR},
    objdetect::CascadeClassifier,
    prelude::*,
    Result,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;
use tokio::sync::Mutex;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectionResult {
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
    pub confidence: f32,
    pub class_name: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProcessedFrame {
    pub detections: Vec<DetectionResult>,
    pub frame_id: u64,
    pub timestamp: u64,
    pub processing_time_ms: u64,
}

pub struct VisionProcessor {
    face_cascade: Arc<Mutex<CascadeClassifier>>,
    frame_counter: Arc<Mutex<u64>>,
}

impl VisionProcessor {
    pub fn new() -> Result<Self> {
        let face_cascade = CascadeClassifier::new(
            "/usr/share/opencv4/haarcascades/haarcascade_frontalface_alt.xml"
        )?;
        
        Ok(VisionProcessor {
            face_cascade: Arc::new(Mutex::new(face_cascade)),
            frame_counter: Arc::new(Mutex::new(0)),
        })
    }
    
    pub async fn process_frame(&self, frame: Mat) -> Result<ProcessedFrame> {
        let start_time = std::time::Instant::now();
        
        // 增加帧计数器
        let mut counter = self.frame_counter.lock().await;
        *counter += 1;
        let frame_id = *counter;
        drop(counter);
        
        // 转换为灰度图像
        let mut gray = Mat::default();
        imgproc::cvt_color(&frame, &mut gray, imgproc::COLOR_BGR2GRAY, 0)?;
        
        // 人脸检测
        let mut faces = Vector::<opencv::core::Rect>::new();
        {
            let cascade = self.face_cascade.lock().await;
            cascade.detect_multi_scale(
                &gray,
                &mut faces,
                1.1,
                3,
                0,
                Size::new(30, 30),
                Size::new(0, 0),
            )?;
        }
        
        // 转换检测结果
        let mut detections = Vec::new();
        for face in faces.iter() {
            detections.push(DetectionResult {
                x: face.x,
                y: face.y,
                width: face.width,
                height: face.height,
                confidence: 0.9, // 简化的置信度
                class_name: "face".to_string(),
            });
        }
        
        let processing_time = start_time.elapsed().as_millis() as u64;
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_millis() as u64;
        
        Ok(ProcessedFrame {
            detections,
            frame_id,
            timestamp,
            processing_time_ms: processing_time,
        })
    }
    
    pub async fn resize_frame(&self, frame: Mat, width: i32, height: i32) -> Result<Mat> {
        let mut resized = Mat::default();
        imgproc::resize(
            &frame,
            &mut resized,
            Size::new(width, height),
            0.0,
            0.0,
            INTER_LINEAR,
        )?;
        Ok(resized)
    }
    
    pub async fn apply_filter(&self, frame: Mat, filter_type: &str) -> Result<Mat> {
        let mut filtered = Mat::default();
        
        match filter_type {
            "blur" => {
                imgproc::gaussian_blur(
                    &frame,
                    &mut filtered,
                    Size::new(15, 15),
                    0.0,
                    0.0,
                    opencv::core::BORDER_DEFAULT,
                )?;
            }
            "edge" => {
                let mut gray = Mat::default();
                imgproc::cvt_color(&frame, &mut gray, imgproc::COLOR_BGR2GRAY, 0)?;
                imgproc::canny(&gray, &mut filtered, 100.0, 200.0, 3, false)?;
                imgproc::cvt_color(&filtered, &mut filtered, imgproc::COLOR_GRAY2BGR, 0)?;
            }
            _ => {
                frame.copy_to(&mut filtered)?;
            }
        }
        
        Ok(filtered)
    }
}

// Python绑定
use pyo3::prelude::*;

#[pyfunction]
fn process_frame_py(frame_data: Vec<u8>) -> PyResult<String> {
    // 这里实现Python接口
    // 将字节数据转换为OpenCV Mat，处理后返回JSON结果
    Ok("{\"status\": \"processed\"}".to_string())
}

#[pymodule]
fn reachy_rust_core(_py: Python, m: &PyModule) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(process_frame_py, m)?)?;
    Ok(())
}
```

#### 实时数据处理模块 (backend/rust/src/realtime.rs)
```rust
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;
use std::sync::Arc;
use tokio::sync::{Mutex, RwLock};
use tokio::time::{Duration, Instant};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SensorData {
    pub timestamp: u64,
    pub temperature: f32,
    pub humidity: f32,
    pub acceleration: [f32; 3],
    pub gyroscope: [f32; 3],
    pub magnetometer: [f32; 3],
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MotorCommand {
    pub motor_id: u8,
    pub position: f32,
    pub velocity: f32,
    pub torque: f32,
    pub timestamp: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemMetrics {
    pub cpu_usage: f32,
    pub memory_usage: f32,
    pub gpu_usage: f32,
    pub temperature: f32,
    pub fps: f32,
    pub latency_ms: u64,
}

pub struct RealtimeDataProcessor {
    sensor_buffer: Arc<Mutex<VecDeque<SensorData>>>,
    command_buffer: Arc<Mutex<VecDeque<MotorCommand>>>,
    metrics: Arc<RwLock<SystemMetrics>>,
    buffer_size: usize,
}

impl RealtimeDataProcessor {
    pub fn new(buffer_size: usize) -> Self {
        Self {
            sensor_buffer: Arc::new(Mutex::new(VecDeque::with_capacity(buffer_size))),
            command_buffer: Arc::new(Mutex::new(VecDeque::with_capacity(buffer_size))),
            metrics: Arc::new(RwLock::new(SystemMetrics {
                cpu_usage: 0.0,
                memory_usage: 0.0,
                gpu_usage: 0.0,
                temperature: 0.0,
                fps: 0.0,
                latency_ms: 0,
            })),
            buffer_size,
        }
    }
    
    pub async fn add_sensor_data(&self, data: SensorData) {
        let mut buffer = self.sensor_buffer.lock().await;
        if buffer.len() >= self.buffer_size {
            buffer.pop_front();
        }
        buffer.push_back(data);
    }
    
    pub async fn add_motor_command(&self, command: MotorCommand) {
        let mut buffer = self.command_buffer.lock().await;
        if buffer.len() >= self.buffer_size {
            buffer.pop_front();
        }
        buffer.push_back(command);
    }
    
    pub async fn get_latest_sensor_data(&self) -> Option<SensorData> {
        let buffer = self.sensor_buffer.lock().await;
        buffer.back().cloned()
    }
    
    pub async fn get_sensor_history(&self, count: usize) -> Vec<SensorData> {
        let buffer = self.sensor_buffer.lock().await;
        buffer.iter().rev().take(count).cloned().collect()
    }
    
    pub async fn process_sensor_fusion(&self) -> Option<SensorData> {
        let buffer = self.sensor_buffer.lock().await;
        if buffer.len() < 3 {
            return None;
        }
        
        // 简单的传感器融合算法
        let recent_data: Vec<_> = buffer.iter().rev().take(3).collect();
        
        let avg_temp = recent_data.iter().map(|d| d.temperature).sum::<f32>() / 3.0;
        let avg_humidity = recent_data.iter().map(|d| d.humidity).sum::<f32>() / 3.0;
        
        // 加速度计数据平滑
        let mut avg_accel = [0.0f32; 3];
        for data in &recent_data {
            for i in 0..3 {
                avg_accel[i] += data.acceleration[i];
            }
        }
        for i in 0..3 {
            avg_accel[i] /= 3.0;
        }
        
        Some(SensorData {
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as u64,
            temperature: avg_temp,
            humidity: avg_humidity,
            acceleration: avg_accel,
            gyroscope: recent_data[0].gyroscope,
            magnetometer: recent_data[0].magnetometer,
        })
    }
    
    pub async fn update_metrics(&self, metrics: SystemMetrics) {
        let mut current_metrics = self.metrics.write().await;
        *current_metrics = metrics;
    }
    
    pub async fn get_metrics(&self) -> SystemMetrics {
        let metrics = self.metrics.read().await;
        metrics.clone()
    }
    
    pub async fn calculate_latency(&self) -> u64 {
        let start = Instant::now();
        
        // 模拟一些处理
        tokio::time::sleep(Duration::from_micros(100)).await;
        
        start.elapsed().as_millis() as u64
    }
    
    pub async fn start_metrics_collection(&self) {
        let metrics_ref = Arc::clone(&self.metrics);
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_millis(100));
            
            loop {
                interval.tick().await;
                
                // 收集系统指标
                let cpu_usage = Self::get_cpu_usage().await;
                let memory_usage = Self::get_memory_usage().await;
                let gpu_usage = Self::get_gpu_usage().await;
                let temperature = Self::get_system_temperature().await;
                
                let new_metrics = SystemMetrics {
                    cpu_usage,
                    memory_usage,
                    gpu_usage,
                    temperature,
                    fps: 30.0, // 简化
                    latency_ms: 5, // 简化
                };
                
                {
                    let mut metrics = metrics_ref.write().await;
                    *metrics = new_metrics;
                }
            }
        });
    }
    
    async fn get_cpu_usage() -> f32 {
        // 实际实现中应该读取系统信息
        45.2
    }
    
    async fn get_memory_usage() -> f32 {
        // 实际实现中应该读取系统信息
        62.8
    }
    
    async fn get_gpu_usage() -> f32 {
        // 实际实现中应该读取GPU信息
        78.5
    }
    
    async fn get_system_temperature() -> f32 {
        // 实际实现中应该读取温度传感器
        42.3
    }
}
```

## 前端详细实现

### 1. React主应用结构

#### 主应用组件 (frontend/src/App.tsx)
```typescript
import React, { useState, useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Toaster } from 'react-hot-toast';

import Header from './components/Layout/Header';
import Sidebar from './components/Layout/Sidebar';
import Dashboard from './pages/Dashboard';
import Control from './pages/Control';
import Settings from './pages/Settings';
import { WebSocketProvider } from './contexts/WebSocketContext';
import { RobotProvider } from './contexts/RobotContext';
import { ThemeProvider } from './contexts/ThemeContext';

import './App.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,
      retry: 1,
    },
  },
});

function App() {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <WebSocketProvider>
          <RobotProvider>
            <Router>
              <div className="flex h-screen bg-gray-100 dark:bg-gray-900">
                {/* 侧边栏 */}
                <Sidebar 
                  isOpen={sidebarOpen} 
                  onClose={() => setSidebarOpen(false)} 
                />
                
                {/* 主内容区域 */}
                <div className="flex-1 flex flex-col overflow-hidden">
                  {/* 顶部导航 */}
                  <Header 
                    onMenuClick={() => setSidebarOpen(true)}
                  />
                  
                  {/* 页面内容 */}
                  <main className="flex-1 overflow-x-hidden overflow-y-auto bg-gray-100 dark:bg-gray-900">
                    <div className="container mx-auto px-6 py-8">
                      <Routes>
                        <Route path="/" element={<Dashboard />} />
                        <Route path="/control" element={<Control />} />
                        <Route path="/settings" element={<Settings />} />
                      </Routes>
                    </div>
                  </main>
                </div>
              </div>
              
              {/* 全局通知 */}
              <Toaster 
                position="top-right"
                toastOptions={{
                  duration: 4000,
                  style: {
                    background: '#363636',
                    color: '#fff',
                  },
                }}
              />
            </Router>
          </RobotProvider>
        </WebSocketProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;
```

#### WebSocket上下文 (frontend/src/contexts/WebSocketContext.tsx)
```typescript
import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';
import toast from 'react-hot-toast';

interface WebSocketMessage {
  type: string;
  payload?: any;
  error?: string;
}

interface WebSocketContextType {
  socket: WebSocket | null;
  isConnected: boolean;
  sendMessage: (message: WebSocketMessage) => void;
  lastMessage: WebSocketMessage | null;
}

const WebSocketContext = createContext<WebSocketContextType | undefined>(undefined);

export const useWebSocket = () => {
  const context = useContext(WebSocketContext);
  if (context === undefined) {
    throw new Error('useWebSocket must be used within a WebSocketProvider');
  }
  return context;
};

interface WebSocketProviderProps {
  children: React.ReactNode;
}

export const WebSocketProvider: React.FC<WebSocketProviderProps> = ({ children }) => {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);
  const [reconnectAttempts, setReconnectAttempts] = useState(0);

  const connect = useCallback(() => {
    try {
      const wsUrl = process.env.REACT_APP_WS_URL || 'ws://localhost:8000/ws/control';
      const newSocket = new WebSocket(wsUrl);

      newSocket.onopen = () => {
        console.log('WebSocket连接已建立');
        setIsConnected(true);
        setReconnectAttempts(0);
        toast.success('已连接到机器人');
      };

      newSocket.onmessage = (event) => {
        try {
          const message: WebSocketMessage = JSON.parse(event.data);
          setLastMessage(message);
          
          // 处理错误消息
          if (message.error) {
            toast.error(`错误: ${message.error}`);
          }
        } catch (error) {
          console.error('解析WebSocket消息失败:', error);
        }
      };

      newSocket.onclose = () => {
        console.log('WebSocket连接已关闭');
        setIsConnected(false);
        setSocket(null);
        
        // 自动重连逻辑
        if (reconnectAttempts < 5) {
          setTimeout(() => {
            setReconnectAttempts(prev => prev + 1);
            connect();
          }, Math.pow(2, reconnectAttempts) * 1000); // 指数退避
        } else {
          toast.error('无法连接到机器人，请检查网络连接');
        }
      };

      newSocket.onerror = (error) => {
        console.error('WebSocket错误:', error);
        toast.error('WebSocket连接错误');
      };

      setSocket(newSocket);
    } catch (error) {
      console.error('创建WebSocket连接失败:', error);
      toast.error('创建连接失败');
    }
  }, [reconnectAttempts]);

  useEffect(() => {
    connect();

    return () => {
      if (socket) {
        socket.close();
      }
    };
  }, []);

  const sendMessage = useCallback((message: WebSocketMessage) => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify(message));
    } else {
      toast.error('WebSocket未连接');
    }
  }, [socket]);

  const value: WebSocketContextType = {
    socket,
    isConnected,
    sendMessage,
    lastMessage,
  };

  return (
    <WebSocketContext.Provider value={value}>
      {children}
    </WebSocketContext.Provider>
  );
};
```

#### 机器人控制上下文 (frontend/src/contexts/RobotContext.tsx)
```typescript
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useWebSocket } from './WebSocketContext';

interface RobotPosition {
  head: {
    pitch: number;
    yaw: number;
    roll: number;
  };
  body: {
    rotation: number;
  };
}

interface RobotStatus {
  connected: boolean;
  position: RobotPosition;
  streaming: boolean;
  temperature: number;
  battery: number;
}

interface RobotContextType {
  status: RobotStatus | null;
  isLoading: boolean;
  moveHead: (pitch: number, yaw: number, roll: number, duration?: number) => void;
  rotateBody: (angle: number, duration?: number) => void;
  startVideoStream: () => void;
  stopVideoStream: () => void;
  refreshStatus: () => void;
}

const RobotContext = createContext<RobotContextType | undefined>(undefined);

export const useRobot = () => {
  const context = useContext(RobotContext);
  if (context === undefined) {
    throw new Error('useRobot must be used within a RobotProvider');
  }
  return context;
};

interface RobotProviderProps {
  children: React.ReactNode;
}

export const RobotProvider: React.FC<RobotProviderProps> = ({ children }) => {
  const { sendMessage, lastMessage, isConnected } = useWebSocket();
  const [status, setStatus] = useState<RobotStatus | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  // 处理WebSocket消息
  useEffect(() => {
    if (lastMessage) {
      switch (lastMessage.type) {
        case 'status_response':
          setStatus(lastMessage.payload.status);
          setIsLoading(false);
          break;
        case 'move_head_response':
          if (lastMessage.payload.success && status) {
            setStatus({
              ...status,
              position: {
                ...status.position,
                head: lastMessage.payload.position,
              },
            });
          }
          break;
        case 'rotate_body_response':
          if (lastMessage.payload.success && status) {
            setStatus({
              ...status,
              position: {
                ...status.position,
                body: { rotation: lastMessage.payload.angle },
              },
            });
          }
          break;
        default:
          break;
      }
    }
  }, [lastMessage, status]);

  // 定期刷新状态
  useEffect(() => {
    if (isConnected) {
      const interval = setInterval(() => {
        refreshStatus();
      }, 5000); // 每5秒刷新一次

      return () => clearInterval(interval);
    }
  }, [isConnected]);

  const moveHead = useCallback((pitch: number, yaw: number, roll: number, duration = 1.0) => {
    sendMessage({
      type: 'move_head',
      payload: { pitch, yaw, roll, duration },
    });
  }, [sendMessage]);

  const rotateBody = useCallback((angle: number, duration = 2.0) => {
    sendMessage({
      type: 'rotate_body',
      payload: { angle, duration },
    });
  }, [sendMessage]);

  const startVideoStream = useCallback(() => {
    sendMessage({
      type: 'start_stream',
    });
  }, [sendMessage]);

  const stopVideoStream = useCallback(() => {
    sendMessage({
      type: 'stop_stream',
    });
  }, [sendMessage]);

  const refreshStatus = useCallback(() => {
    if (isConnected) {
      setIsLoading(true);
      sendMessage({
        type: 'get_status',
      });
    }
  }, [sendMessage, isConnected]);

  // 初始状态获取
  useEffect(() => {
    if (isConnected && !status) {
      refreshStatus();
    }
  }, [isConnected, status, refreshStatus]);

  const value: RobotContextType = {
    status,
    isLoading,
    moveHead,
    rotateBody,
    startVideoStream,
    stopVideoStream,
    refreshStatus,
  };

  return (
    <RobotContext.Provider value={value}>
      {children}
    </RobotContext.Provider>
  );
};
```

### 2. 核心控制组件

#### 视频流组件 (frontend/src/components/VideoStream/VideoStream.tsx)
```typescript
import React, { useRef, useEffect, useState } from 'react';
import { Play, Pause, Camera, Settings } from 'lucide-react';
import { useRobot } from '../../contexts/RobotContext';

interface VideoStreamProps {
  className?: string;
}

const VideoStream: React.FC<VideoStreamProps> = ({ className = '' }) => {
  const videoRef = useRef<HTMLVideoElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isStreaming, setIsStreaming] = useState(false);
  const [streamSocket, setStreamSocket] = useState<WebSocket | null>(null);
  const [error, setError] = useState<string | null>(null);
  const { status } = useRobot();

  useEffect(() => {
    return () => {
      if (streamSocket) {
        streamSocket.close();
      }
    };
  }, [streamSocket]);

  const startStream = async () => {
    try {
      setError(null);
      const wsUrl = process.env.REACT_APP_STREAM_WS_URL || 'ws://localhost:8000/ws/stream';
      const socket = new WebSocket(wsUrl);

      socket.onopen = () => {
        console.log('视频流WebSocket连接已建立');
        setIsStreaming(true);
        setStreamSocket(socket);
      };

      socket.onmessage = (event) => {
        if (event.data instanceof Blob) {
          // 处理视频帧数据
          const url = URL.createObjectURL(event.data);
          const img = new Image();
          
          img.onload = () => {
            if (canvasRef.current) {
              const canvas = canvasRef.current;
              const ctx = canvas.getContext('2d');
              if (ctx) {
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
              }
            }
            URL.revokeObjectURL(url);
          };
          
          img.src = url;
        }
      };

      socket.onclose = () => {
        console.log('视频流WebSocket连接已关闭');
        setIsStreaming(false);
        setStreamSocket(null);
      };

      socket.onerror = (error) => {
        console.error('视频流WebSocket错误:', error);
        setError('视频流连接失败');
        setIsStreaming(false);
      };

    } catch (error) {
      console.error('启动视频流失败:', error);
      setError('启动视频流失败');
    }
  };

  const stopStream = () => {
    if (streamSocket) {
      streamSocket.close();
      setStreamSocket(null);
    }
    setIsStreaming(false);
  };

  const takeScreenshot = () => {
    if (canvasRef.current) {
      const canvas = canvasRef.current;
      const link = document.createElement('a');
      link.download = `reachy-screenshot-${Date.now()}.png`;
      link.href = canvas.toDataURL();
      link.click();
    }
  };

  return (
    <div className={`bg-white dark:bg-gray-800 rounded-lg shadow-lg ${className}`}>
      {/* 控制栏 */}
      <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
          实时视频流
        </h3>
        <div className="flex items-center space-x-2">
          <button
            onClick={isStreaming ? stopStream : startStream}
            className={`flex items-center px-3 py-2 rounded-md text-sm font-medium ${
              isStreaming
                ? 'bg-red-100 text-red-700 hover:bg-red-200 dark:bg-red-900 dark:text-red-300'
                : 'bg-green-100 text-green-700 hover:bg-green-200 dark:bg-green-900 dark:text-green-300'
            }`}
            disabled={!status?.connected}
          >
            {isStreaming ? (
              <>
                <Pause className="w-4 h-4 mr-1" />
                停止
              </>
            ) : (
              <>
                <Play className="w-4 h-4 mr-1" />
                开始
              </>
            )}
          </button>
          
          <button
            onClick={takeScreenshot}
            className="flex items-center px-3 py-2 rounded-md text-sm font-medium bg-blue-100 text-blue-700 hover:bg-blue-200 dark:bg-blue-900 dark:text-blue-300"
            disabled={!isStreaming}
          >
            <Camera className="w-4 h-4 mr-1" />
            截图
          </button>
          
          <button className="flex items-center px-3 py-2 rounded-md text-sm font-medium bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300">
            <Settings className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* 视频显示区域 */}
      <div className="relative bg-black rounded-b-lg overflow-hidden" style={{ aspectRatio: '16/9' }}>
        {error ? (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center text-red-400">
              <Camera className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>{error}</p>
            </div>
          </div>
        ) : !isStreaming ? (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center text-gray-400">
              <Camera className="w-12 h-12 mx-auto mb-2 opacity-50" />
              <p>点击开始按钮启动视频流</p>
            </div>
          </div>
        ) : null}
        
        <canvas
          ref={canvasRef}
          className="w-full h-full object-contain"
          style={{ display: isStreaming && !error ? 'block' : 'none' }}
        />
        
        {/* 状态指示器 */}
        {isStreaming && (
          <div className="absolute top-4 left-4">
            <div className="flex items-center px-2 py-1 bg-red-600 text-white text-xs rounded-full">
              <div className="w-2 h-2 bg-white rounded-full mr-1 animate-pulse" />
              LIVE
            </div>
          </div>
        )}
        
        {/* 连接状态 */}
        <div className="absolute top-4 right-4">
          <div className={`flex items-center px-2 py-1 text-xs rounded-full ${
            status?.connected
              ? 'bg-green-600 text-white'
              : 'bg-red-600 text-white'
          }`}>
            <div className={`w-2 h-2 rounded-full mr-1 ${
              status?.connected ? 'bg-white' : 'bg-white animate-pulse'
            }`} />
            {status?.connected ? '已连接' : '未连接'}
          </div>
        </div>
      </div>
    </div>
  );
};

export default VideoStream;
```

#### 运动控制组件 (frontend/src/components/Controls/MovementControls.tsx)
```typescript
import React, { useState, useCallback } from 'react';
import { RotateCcw, Move, Zap } from 'lucide-react';
import { useRobot } from '../../contexts/RobotContext';
import Joystick from './Joystick';
import Slider from '../UI/Slider';

interface MovementControlsProps {
  className?: string;
}

const MovementControls: React.FC<MovementControlsProps> = ({ className = '' }) => {
  const { status, moveHead, rotateBody } = useRobot();
  const [headPosition, setHeadPosition] = useState({ pitch: 0, yaw: 0, roll: 0 });
  const [bodyRotation, setBodyRotation] = useState(0);
  const [movementSpeed, setMovementSpeed] = useState(1.0);

  const handleJoystickMove = useCallback((x: number, y: number) => {
    // 将摇杆输入转换为头部运动
    const yaw = x * 90; // -90 到 90 度
    const pitch = -y * 30; // -30 到 30 度
    
    setHeadPosition(prev => ({ ...prev, pitch, yaw }));
    moveHead(pitch, yaw, headPosition.roll, movementSpeed);
  }, [moveHead, headPosition.roll, movementSpeed]);

  const handleRollChange = useCallback((roll: number) => {
    setHeadPosition(prev => ({ ...prev, roll }));
    moveHead(headPosition.pitch, headPosition.yaw, roll, movementSpeed);
  }, [moveHead, headPosition.pitch, headPosition.yaw, movementSpeed]);

  const handleBodyRotation = useCallback((angle: number) => {
    setBodyRotation(angle);
    rotateBody(angle, movementSpeed * 2);
  }, [rotateBody, movementSpeed]);

  const resetPosition = useCallback(() => {
    setHeadPosition({ pitch: 0, yaw: 0, roll: 0 });
    setBodyRotation(0);
    moveHead(0, 0, 0, movementSpeed);
    rotateBody(0, movementSpeed * 2);
  }, [moveHead, rotateBody, movementSpeed]);

  return (
    <div className={`bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 ${className}`}>
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
          运动控制
        </h3>
        <button
          onClick={resetPosition}
          className="flex items-center px-3 py-2 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-700 dark:text-gray-300 rounded-md text-sm font-medium"
          disabled={!status?.connected}
        >
          <RotateCcw className="w-4 h-4 mr-1" />
          复位
        </button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* 头部控制 */}
        <div className="space-y-4">
          <h4 className="text-md font-medium text-gray-900 dark:text-white flex items-center">
            <Move className="w-4 h-4 mr-2" />
            头部控制
          </h4>
          
          {/* 摇杆控制 */}
          <div className="flex justify-center">
            <Joystick
              size={120}
              onMove={handleJoystickMove}
              disabled={!status?.connected}
            />
          </div>
          
          {/* Roll控制 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Roll: {headPosition.roll.toFixed(1)}°
            </label>
            <Slider
              min={-30}
              max={30}
              value={headPosition.roll}
              onChange={handleRollChange}
              disabled={!status?.connected}
            />
          </div>
        </div>

        {/* 身体控制 */}
        <div className="space-y-4">
          <h4 className="text-md font-medium text-gray-900 dark:text-white flex items-center">
            <RotateCcw className="w-4 h-4 mr-2" />
            身体旋转
          </h4>
          
          {/* 旋转控制 */}
          <div className="flex justify-center">
            <div className="relative w-32 h-32">
              <div className="absolute inset-0 rounded-full border-4 border-gray-200 dark:border-gray-600" />
              <div 
                className="absolute inset-2 rounded-full bg-blue-500 cursor-pointer transition-transform"
                style={{ transform: `rotate(${bodyRotation}deg)` }}
                onClick={() => handleBodyRotation(bodyRotation + 45)}
              >
                <div className="absolute top-1 left-1/2 w-1 h-4 bg-white rounded transform -translate-x-1/2" />
              </div>
            </div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              旋转角度: {bodyRotation.toFixed(1)}°
            </label>
            <Slider
              min={-180}
              max={180}
              value={bodyRotation}
              onChange={handleBodyRotation}
              disabled={!status?.connected}
            />
          </div>
        </div>
      </div>

      {/* 速度控制 */}
      <div className="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
        <div className="flex items-center justify-between mb-2">
          <label className="text-sm font-medium text-gray-700 dark:text-gray-300 flex items-center">
            <Zap className="w-4 h-4 mr-1" />
            运动速度
          </label>
          <span className="text-sm text-gray-500 dark:text-gray-400">
            {movementSpeed.toFixed(1)}x
          </span>
        </div>
        <Slider
          min={0.1}
          max={3.0}
          step={0.1}
          value={movementSpeed}
          onChange={setMovementSpeed}
        />
      </div>

      {/* 当前位置显示 */}
      <div className="mt-6 pt-6 border-t border-gray-200 dark:border-gray-700">
        <h5 className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
          当前位置
        </h5>
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div className="space-y-1">
            <div className="flex justify-between">
              <span className="text-gray-600 dark:text-gray-400">Pitch:</span>
              <span className="font-mono">{status?.position?.head?.pitch?.toFixed(1) || '0.0'}°</span>
            </div>
            <div className="flex justify-between">
              <span className="text-gray-600 dark:text-gray-400">Yaw:</span>
              <span className="font-mono">{status?.position?.head?.yaw?.toFixed(1) || '0.0'}°</span>
            </div>
          </div>
          <div className="space-y-1">
            <div className="flex justify-between">
              <span className="text-gray-600 dark:text-gray-400">Roll:</span>
              <span className="font-mono">{status?.position?.head?.roll?.toFixed(1) || '0.0'}°</span>
            </div>
            <div className="flex justify-between">
              <span className="text-gray-600 dark:text-gray-400">Body:</span>
              <span className="font-mono">{status?.position?.body?.rotation?.toFixed(1) || '0.0'}°</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MovementControls;
```

## 部署配置文件

### 1. Docker配置

#### 后端Dockerfile (config/docker/Dockerfile.backend)
```dockerfile
# 多阶段构建
FROM nvcr.io/nvidia/l4t-pytorch:r35.2.1-pth2.0-py3 as base

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    python3-pip \
    python3-dev \
    build-essential \
    cmake \
    pkg-config \
    libopencv-dev \
    libgstreamer1.0-dev \
    libgstreamer-plugins-base1.0-dev \
    ros-humble-desktop \
    curl \
    && rm -rf /var/lib/apt/lists/*

# 安装Rust
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
ENV PATH="/root/.cargo/bin:${PATH}"

# 复制依赖文件
COPY backend/python/requirements.txt ./python/
COPY backend/rust/Cargo.toml ./rust/

# 安装Python依赖
RUN pip3 install --no-cache-dir -r python/requirements.txt

# 构建Rust模块
COPY backend/rust ./rust/
WORKDIR /app/rust
RUN cargo build --release

# 复制Python代码
WORKDIR /app
COPY backend/python ./python/

# 设置环境变量
ENV PYTHONPATH="/app/python:${PYTHONPATH}"
ENV ROS_DOMAIN_ID=42
ENV CUDA_VISIBLE_DEVICES=0

# 暴露端口
EXPOSE 8000

# 启动脚本
COPY scripts/start-backend.sh /start-backend.sh
RUN chmod +x /start-backend.sh

CMD ["/start-backend.sh"]
```

#### 前端Dockerfile (config/docker/Dockerfile.frontend)
```dockerfile
# 构建阶段
FROM node:18-alpine as builder

WORKDIR /app

# 复制package文件
COPY frontend/package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源码
COPY frontend/ .

# 构建应用
RUN npm run build

# 生产阶段
FROM nginx:alpine

# 复制构建结果
COPY --from=builder /app/build /usr/share/nginx/html

# 复制nginx配置
COPY config/nginx/nginx.conf /etc/nginx/nginx.conf
COPY config/nginx/default.conf /etc/nginx/conf.d/default.conf

# 暴露端口
EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### 2. Docker Compose配置

#### docker-compose.yml
```yaml
version: '3.8'

services:
  # 后端服务
  backend:
    build:
      context: .
      dockerfile: config/docker/Dockerfile.backend
    container_name: reachy-backend
    ports:
      - "8000:8000"
    devices:
      - "/dev/video0:/dev/video0"
      - "/dev/video1:/dev/video1"
    volumes:
      - ./models:/app/models:ro
      - ./logs:/app/logs
      - /tmp/.X11-unix:/tmp/.X11-unix:rw
    environment:
      - DISPLAY=${DISPLAY}
      - CUDA_VISIBLE_DEVICES=0
      - ROS_DOMAIN_ID=42
      - PYTHONPATH=/app/python
      - LOG_LEVEL=INFO
    runtime: nvidia
    restart: unless-stopped
    networks:
      - reachy-network
    depends_on:
      - redis
      - postgres

  # 前端服务
  frontend:
    build:
      context: .
      dockerfile: config/docker/Dockerfile.frontend
    container_name: reachy-frontend
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_URL=http://localhost:8000
      - REACT_APP_WS_URL=ws://localhost:8000/ws/control
      - REACT_APP_STREAM_WS_URL=ws://localhost:8000/ws/stream
    restart: unless-stopped
    networks:
      - reachy-network
    depends_on:
      - backend

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: reachy-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    restart: unless-stopped
    networks:
      - reachy-network

  # PostgreSQL数据库
  postgres:
    image: postgres:15-alpine
    container_name: reachy-postgres
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=reachy
      - POSTGRES_USER=reachy
      - POSTGRES_PASSWORD=reachy123
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./config/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    networks:
      - reachy-network

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: reachy-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./config/nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./config/nginx/sites:/etc/nginx/conf.d
      - ./ssl:/etc/nginx/ssl
    restart: unless-stopped
    networks:
      - reachy-network
    depends_on:
      - frontend
      - backend

volumes:
  redis-data:
  postgres-data:

networks:
  reachy-network:
    driver: bridge
```

### 3. 环境配置

#### 开发环境配置 (config/env/.env.development)
```bash
# 应用配置
APP_NAME="Reachy Mini Control"
APP_VERSION="1.0.0"
ENVIRONMENT="development"
DEBUG=true

# 服务器配置
HOST="0.0.0.0"
PORT=8000
WORKERS=1

# 数据库配置
DATABASE_URL="postgresql://reachy:reachy123@localhost:5432/reachy"
REDIS_URL="redis://localhost:6379/0"

# Reachy机器人配置
REACHY_HOST="localhost"
REACHY_PORT=50055
REACHY_TIMEOUT=30

# AI模型配置
MODEL_PATH="/app/models"
VISION_MODEL="yolov8n.pt"
AUDIO_MODEL="whisper-base"
NLP_MODEL="distilbert-base"

# 日志配置
LOG_LEVEL="INFO"
LOG_FILE="/app/logs/reachy.log"
LOG_MAX_SIZE="10MB"
LOG_BACKUP_COUNT=5

# 安全配置
SECRET_KEY="your-secret-key-here"
JWT_ALGORITHM="HS256"
JWT_EXPIRE_MINUTES=1440

# CORS配置
ALLOWED_ORIGINS="http://localhost:3000,http://127.0.0.1:3000"
ALLOWED_METHODS="GET,POST,PUT,DELETE,OPTIONS"
ALLOWED_HEADERS="*"

# WebSocket配置
WS_HEARTBEAT_INTERVAL=30
WS_MAX_CONNECTIONS=10

# 视频流配置
VIDEO_WIDTH=640
VIDEO_HEIGHT=480
VIDEO_FPS=30
VIDEO_QUALITY=80

# GPU配置
CUDA_VISIBLE_DEVICES=0
TENSORRT_CACHE_PATH="/app/cache/tensorrt"

# ROS2配置
ROS_DOMAIN_ID=42
ROS_LOCALHOST_ONLY=1
```

#### 生产环境配置 (config/env/.env.production)
```bash
# 应用配置
APP_NAME="Reachy Mini Control"
APP_VERSION="1.0.0"
ENVIRONMENT="production"
DEBUG=false

# 服务器配置
HOST="0.0.0.0"
PORT=8000
WORKERS=4

# 数据库配置
DATABASE_URL="postgresql://reachy:${POSTGRES_PASSWORD}@postgres:5432/reachy"
REDIS_URL="redis://redis:6379/0"

# Reachy机器人配置
REACHY_HOST="localhost"
REACHY_PORT=50055
REACHY_TIMEOUT=30

# AI模型配置
MODEL_PATH="/app/models"
VISION_MODEL="yolov8s.pt"
AUDIO_MODEL="whisper-small"
NLP_MODEL="bert-base"

# 日志配置
LOG_LEVEL="WARNING"
LOG_FILE="/app/logs/reachy.log"
LOG_MAX_SIZE="50MB"
LOG_BACKUP_COUNT=10

# 安全配置
SECRET_KEY="${SECRET_KEY}"
JWT_ALGORITHM="HS256"
JWT_EXPIRE_MINUTES=720

# CORS配置
ALLOWED_ORIGINS="https://yourdomain.com"
ALLOWED_METHODS="GET,POST,PUT,DELETE"
ALLOWED_HEADERS="Content-Type,Authorization"

# WebSocket配置
WS_HEARTBEAT_INTERVAL=60
WS_MAX_CONNECTIONS=5

# 视频流配置
VIDEO_WIDTH=1280
VIDEO_HEIGHT=720
VIDEO_FPS=30
VIDEO_QUALITY=85

# GPU配置
CUDA_VISIBLE_DEVICES=0
TENSORRT_CACHE_PATH="/app/cache/tensorrt"

# ROS2配置
ROS_DOMAIN_ID=42
ROS_LOCALHOST_ONLY=0
```

### 4. 启动脚本

#### 后端启动脚本 (scripts/start-backend.sh)
```bash
#!/bin/bash

# 设置错误处理
set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}启动 Reachy Mini 后端服务...${NC}"

# 检查环境变量
if [ -z "$PYTHONPATH" ]; then
    export PYTHONPATH="/app/python:$PYTHONPATH"
fi

# 检查CUDA可用性
if command -v nvidia-smi &> /dev/null; then
    echo -e "${GREEN}检测到NVIDIA GPU:${NC}"
    nvidia-smi --query-gpu=name,memory.total,memory.used --format=csv,noheader,nounits
else
    echo -e "${YELLOW}警告: 未检测到NVIDIA GPU，将使用CPU模式${NC}"
fi

# 等待数据库服务启动
echo -e "${YELLOW}等待数据库服务启动...${NC}"
while ! nc -z postgres 5432; do
    sleep 1
done
echo -e "${GREEN}数据库服务已就绪${NC}"

# 等待Redis服务启动
echo -e "${YELLOW}等待Redis服务启动...${NC}"
while ! nc -z redis 6379; do
    sleep 1
done
echo -e "${GREEN}Redis服务已就绪${NC}"

# 运行数据库迁移
echo -e "${YELLOW}运行数据库迁移...${NC}"
cd /app/python
python -m alembic upgrade head

# 初始化ROS2环境
echo -e "${YELLOW}初始化ROS2环境...${NC}"
source /opt/ros/humble/setup.bash
export ROS_DOMAIN_ID=${ROS_DOMAIN_ID:-42}

# 启动后端服务
echo -e "${GREEN}启动FastAPI服务器...${NC}"
exec uvicorn main:app \
    --host ${HOST:-0.0.0.0} \
    --port ${PORT:-8000} \
    --workers ${WORKERS:-1} \
    --log-level ${LOG_LEVEL:-info} \
    --access-log \
    --reload-dir /app/python
```

#### 开发环境启动脚本 (scripts/dev-start.sh)
```bash
#!/bin/bash

# 设置错误处理
set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Reachy Mini 开发环境启动 ===${NC}"

# 检查Docker和Docker Compose
if ! command -v docker &> /dev/null; then
    echo -e "${RED}错误: Docker未安装${NC}"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    echo -e "${RED}错误: Docker Compose未安装${NC}"
    exit 1
fi

# 检查NVIDIA Docker运行时
if ! docker info | grep -q nvidia; then
    echo -e "${YELLOW}警告: NVIDIA Docker运行时未配置，GPU功能可能不可用${NC}"
fi

# 创建必要的目录
echo -e "${YELLOW}创建必要的目录...${NC}"
mkdir -p logs models cache/tensorrt ssl

# 设置环境变量
echo -e "${YELLOW}设置环境变量...${NC}"
export COMPOSE_PROJECT_NAME=reachy-mini
export DISPLAY=${DISPLAY:-:0}

# 构建并启动服务
echo -e "${GREEN}构建并启动开发环境...${NC}"
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up --build -d

# 等待服务启动
echo -e "${YELLOW}等待服务启动...${NC}"
sleep 10

# 检查服务状态
echo -e "${BLUE}=== 服务状态 ===${NC}"
docker-compose ps

# 显示访问信息
echo -e "${GREEN}=== 服务访问信息 ===${NC}"
echo -e "前端界面: ${BLUE}http://localhost:3000${NC}"
echo -e "后端API: ${BLUE}http://localhost:8000${NC}"
echo -e "API文档: ${BLUE}http://localhost:8000/docs${NC}"
echo -e "数据库: ${BLUE}postgresql://reachy:reachy123@localhost:5432/reachy${NC}"
echo -e "Redis: ${BLUE}redis://localhost:6379${NC}"

echo -e "${GREEN}开发环境启动完成！${NC}"
```

#### 生产环境部署脚本 (scripts/deploy.sh)
```bash
#!/bin/bash

# 设置错误处理
set -e

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}=== Reachy Mini 生产环境部署 ===${NC}"

# 检查参数
if [ $# -eq 0 ]; then
    echo -e "${RED}用法: $0 <环境名称> [版本标签]${NC}"
    echo -e "环境名称: production, staging"
    exit 1
fi

ENVIRONMENT=$1
VERSION=${2:-latest}

echo -e "${YELLOW}部署环境: $ENVIRONMENT${NC}"
echo -e "${YELLOW}版本标签: $VERSION${NC}"

# 检查环境配置文件
ENV_FILE="config/env/.env.$ENVIRONMENT"
if [ ! -f "$ENV_FILE" ]; then
    echo -e "${RED}错误: 环境配置文件 $ENV_FILE 不存在${NC}"
    exit 1
fi

# 加载环境变量
echo -e "${YELLOW}加载环境配置...${NC}"
source "$ENV_FILE"

# 检查必要的环境变量
required_vars=("SECRET_KEY" "POSTGRES_PASSWORD")
for var in "${required_vars[@]}"; do
    if [ -z "${!var}" ]; then
        echo -e "${RED}错误: 环境变量 $var 未设置${NC}"
        exit 1
    fi
done

# 创建备份
echo -e "${YELLOW}创建数据备份...${NC}"
if docker-compose ps | grep -q postgres; then
    BACKUP_FILE="backup/db_backup_$(date +%Y%m%d_%H%M%S).sql"
    mkdir -p backup
    docker-compose exec -T postgres pg_dump -U reachy reachy > "$BACKUP_FILE"
    echo -e "${GREEN}数据库备份已保存到: $BACKUP_FILE${NC}"
fi

# 拉取最新镜像
echo -e "${YELLOW}拉取最新镜像...${NC}"
docker-compose pull

# 构建新镜像
echo -e "${YELLOW}构建应用镜像...${NC}"
docker-compose build --no-cache

# 停止旧服务
echo -e "${YELLOW}停止旧服务...${NC}"
docker-compose down

# 启动新服务
echo -e "${GREEN}启动新服务...${NC}"
docker-compose -f docker-compose.yml -f "docker-compose.$ENVIRONMENT.yml" up -d

# 等待服务启动
echo -e "${YELLOW}等待服务启动...${NC}"
sleep 30

# 健康检查
echo -e "${YELLOW}执行健康检查...${NC}"
max_attempts=30
attempt=1

while [ $attempt -le $max_attempts ]; do
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        echo -e "${GREEN}健康检查通过${NC}"
        break
    fi
    
    if [ $attempt -eq $max_attempts ]; then
        echo -e "${RED}健康检查失败，部署可能存在问题${NC}"
        docker-compose logs --tail=50
        exit 1
    fi
    
    echo -e "${YELLOW}等待服务就绪... ($attempt/$max_attempts)${NC}"
    sleep 2
    ((attempt++))
done

# 清理旧镜像
echo -e "${YELLOW}清理旧镜像...${NC}"
docker image prune -f

# 显示部署信息
echo -e "${GREEN}=== 部署完成 ===${NC}"
echo -e "环境: $ENVIRONMENT"
echo -e "版本: $VERSION"
echo -e "时间: $(date)"

# 显示服务状态
echo -e "${BLUE}=== 服务状态 ===${NC}"
docker-compose ps

echo -e "${GREEN}生产环境部署成功！${NC}"
```

## 开发指南

### 1. 环境搭建

#### 系统要求
- **硬件**: Allspark2-Orin NX或兼容的NVIDIA Jetson设备
- **操作系统**: Ubuntu 20.04/22.04 LTS (ARM64)
- **内存**: 至少8GB RAM
- **存储**: 至少64GB可用空间
- **GPU**: NVIDIA GPU支持CUDA 11.4+

#### 依赖安装
```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 安装基础依赖
sudo apt install -y \
    curl \
    wget \
    git \
    build-essential \
    cmake \
    pkg-config \
    python3 \
    python3-pip \
    python3-dev \
    nodejs \
    npm

# 安装Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh
sudo usermod -aG docker $USER

# 安装Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 安装NVIDIA Container Toolkit
distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -
curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list
sudo apt update && sudo apt install -y nvidia-container-toolkit
sudo systemctl restart docker

# 安装Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env
```

#### 项目克隆和初始化
```bash
# 克隆项目
git clone <repository-url> reachy-mini
cd reachy-mini

# 设置权限
chmod +x scripts/*.sh

# 创建环境配置
cp config/env/.env.development .env

# 编辑配置文件
nano .env
```

### 2. 开发流程

#### 启动开发环境
```bash
# 启动完整开发环境
./scripts/dev-start.sh

# 或者分别启动服务
docker-compose up -d postgres redis

# 启动后端开发服务器
cd backend/python
pip install -r requirements.txt
uvicorn main:app --reload --host 0.0.0.0 --port 8000

# 启动前端开发服务器
cd frontend
npm install
npm start
```

#### 代码结构说明
```
reachy-mini/
├── backend/                 # 后端代码
│   ├── python/             # Python服务
│   │   ├── main.py         # FastAPI应用入口
│   │   ├── api/            # API路由
│   │   ├── core/           # 核心功能
│   │   ├── models/         # 数据模型
│   │   ├── services/       # 业务服务
│   │   └── utils/          # 工具函数
│   └── rust/               # Rust模块
│       ├── src/            # Rust源码
│       ├── Cargo.toml      # Rust依赖
│       └── build.rs        # 构建脚本
├── frontend/               # 前端代码
│   ├── src/                # React源码
│   │   ├── components/     # 组件
│   │   ├── contexts/       # 上下文
│   │   ├── hooks/          # 自定义Hook
│   │   ├── services/       # 服务层
│   │   └── utils/          # 工具函数
│   ├── public/             # 静态资源
│   └── package.json        # 前端依赖
├── config/                 # 配置文件
│   ├── docker/             # Docker配置
│   ├── nginx/              # Nginx配置
│   ├── env/                # 环境配置
│   └── postgres/           # 数据库配置
├── scripts/                # 脚本文件
├── docs/                   # 文档
├── tests/                  # 测试文件
└── docker-compose.yml      # Docker编排
```

#### 开发规范

**Python代码规范**:
- 使用Black进行代码格式化
- 使用isort进行导入排序
- 使用mypy进行类型检查
- 使用pytest进行单元测试

```bash
# 代码格式化
black backend/python/
isort backend/python/

# 类型检查
mypy backend/python/

# 运行测试
pytest tests/
```

**Rust代码规范**:
- 使用rustfmt进行代码格式化
- 使用clippy进行代码检查
- 使用cargo test进行测试

```bash
# 代码格式化
cd backend/rust
cargo fmt

# 代码检查
cargo clippy

# 运行测试
cargo test
```

**前端代码规范**:
- 使用Prettier进行代码格式化
- 使用ESLint进行代码检查
- 使用Jest进行单元测试

```bash
# 代码格式化
cd frontend
npm run format

# 代码检查
npm run lint

# 运行测试
npm test
```

### 3. 调试指南

#### 后端调试
```bash
# 查看后端日志
docker-compose logs -f backend

# 进入后端容器
docker-compose exec backend bash

# Python调试
cd backend/python
python -m pdb main.py

# Rust调试
cd backend/rust
cargo run --bin debug_tool
```

#### 前端调试
```bash
# 查看前端日志
docker-compose logs -f frontend

# 开发模式调试
cd frontend
npm start

# 构建调试
npm run build
npm run serve
```

#### 网络调试
```bash
# 检查端口占用
netstat -tulpn | grep :8000

# 测试API连接
curl -X GET http://localhost:8000/health

# 测试WebSocket连接
wscat -c ws://localhost:8000/ws/control
```

### 4. 性能优化

#### GPU优化
```bash
# 检查GPU状态
nvidia-smi

# 监控GPU使用
watch -n 1 nvidia-smi

# TensorRT优化
export TENSORRT_CACHE_PATH=/app/cache/tensorrt
```

#### 内存优化
```bash
# 监控内存使用
free -h
htop

# Docker内存限制
docker-compose exec backend cat /sys/fs/cgroup/memory/memory.limit_in_bytes
```

#### 网络优化
```bash
# 网络延迟测试
ping localhost

# 带宽测试
iperf3 -s  # 服务端
iperf3 -c localhost  # 客户端
```

### 5. 故障排除

#### 常见问题

**1. Docker构建失败**
```bash
# 清理Docker缓存
docker system prune -a

# 重新构建
docker-compose build --no-cache
```

**2. GPU不可用**
```bash
# 检查NVIDIA驱动
nvidia-smi

# 检查Docker GPU支持
docker run --rm --gpus all nvidia/cuda:11.4-base-ubuntu20.04 nvidia-smi
```

**3. 端口冲突**
```bash
# 查找占用端口的进程
sudo lsof -i :8000

# 杀死进程
sudo kill -9 <PID>
```

**4. 权限问题**
```bash
# 修复文件权限
sudo chown -R $USER:$USER .
chmod +x scripts/*.sh
```

**5. 依赖问题**
```bash
# Python依赖冲突
pip install --force-reinstall -r requirements.txt

# Node.js依赖问题
rm -rf node_modules package-lock.json
npm install
```

## 总结

本技术实现方案为在Allspark2-Orin NX平台上开发Reachy Mini机器人项目提供了完整的技术框架和实施细节。方案涵盖了从系统架构设计到具体代码实现，从开发环境搭建到生产部署的全流程指导。

### 主要特点

1. **模块化架构**: 采用微服务架构，前后端分离，便于维护和扩展
2. **高性能计算**: 充分利用Allspark2-Orin NX的GPU计算能力
3. **实时交互**: 基于WebSocket的实时通信和视频流传输
4. **容器化部署**: 使用Docker和Docker Compose简化部署流程
5. **多语言支持**: Python和Rust混合开发，发挥各自优势
6. **现代化前端**: React + TypeScript构建响应式用户界面

### 技术优势

- **可扩展性**: 模块化设计支持功能扩展和性能优化
- **可维护性**: 清晰的代码结构和完善的文档
- **高性能**: GPU加速的AI推理和实时数据处理
- **用户友好**: 直观的Web界面和丰富的交互功能
- **部署简便**: 一键部署和自动化运维

该方案为Reachy Mini机器人在Allspark2-Orin NX平台上的成功实施提供了坚实的技术基础。